name: Release Build

on:
  push:
    tags:
      - "v*"

permissions:
  contents: write

env:
  CARGO_INCREMENTAL: 0

jobs:
  create-release:
    runs-on: ubuntu-latest
    outputs:
      release_id: ${{ steps.create_release.outputs.id }}
    steps:
      - uses: actions/checkout@v4

      - name: Get version from tag
        id: version
        run: echo "VERSION=${GITHUB_REF#refs/tags/v}" >> "$GITHUB_OUTPUT"

      - name: Create Release
        id: create_release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ github.ref_name }}
          name: Mini-HBUT ${{ steps.version.outputs.VERSION }}
          draft: false
          prerelease: false
          body: ""
          generate_release_notes: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      - name: Clean old packaged assets of this tag
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const releaseId = Number("${{ steps.create_release.outputs.id }}");
            if (!releaseId) {
              core.warning("release id is empty, skip cleanup");
              return;
            }
            const { data: assets } = await github.rest.repos.listReleaseAssets({
              owner,
              repo,
              release_id: releaseId,
              per_page: 100
            });
            const targets = assets.filter(a => /^Mini-HBUT_/i.test(a.name));
            for (const asset of targets) {
              core.info(`delete old asset: ${asset.name}`);
              await github.rest.repos.deleteReleaseAsset({
                owner,
                repo,
                asset_id: asset.id
              });
            }

  build-android:
    needs: create-release
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Java
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: "17"

      - name: Setup Android SDK
        uses: android-actions/setup-android@v3

      - name: Setup NDK
        run: |
          sdkmanager "ndk;27.0.11718014"
          echo "NDK_HOME=$ANDROID_SDK_ROOT/ndk/27.0.11718014" >> "$GITHUB_ENV"

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: npm

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: aarch64-linux-android

      - name: Install dependencies
        run: npm ci

      - name: Initialize Android project
        run: npm run tauri android init

      - name: Patch Android notification permissions
        run: |
          set -euo pipefail
          MANIFEST="src-tauri/gen/android/app/src/main/AndroidManifest.xml"
          if [ ! -f "$MANIFEST" ]; then
            echo "AndroidManifest.xml not found: $MANIFEST"
            exit 1
          fi
          python - <<'PY'
          from pathlib import Path
          p = Path("src-tauri/gen/android/app/src/main/AndroidManifest.xml")
          text = p.read_text(encoding="utf-8")
          perms = [
              "android.permission.POST_NOTIFICATIONS",
              "android.permission.WAKE_LOCK",
              "android.permission.FOREGROUND_SERVICE",
              "android.permission.REQUEST_IGNORE_BATTERY_OPTIMIZATIONS",
          ]
          for perm in perms:
              marker = f'android:name="{perm}"'
              if marker not in text:
                  text = text.replace(
                      "<application",
                      f'    <uses-permission android:name="{perm}" />\\n\\n    <application',
                      1,
                  )
          p.write_text(text, encoding="utf-8")
          print("Patched AndroidManifest permissions.")
          PY
          grep -n "POST_NOTIFICATIONS\\|WAKE_LOCK\\|FOREGROUND_SERVICE\\|REQUEST_IGNORE_BATTERY_OPTIMIZATIONS" "$MANIFEST"

      - name: Copy Android icons
        run: |
          set -euo pipefail
          ANDROID_RES="src-tauri/gen/android/app/src/main/res"
          ICONS_SRC="src-tauri/icons/android"
          for density in hdpi mdpi xhdpi xxhdpi xxxhdpi; do
            if [ -d "$ICONS_SRC/$density" ]; then
              mkdir -p "$ANDROID_RES/mipmap-$density"
              cp -f "$ICONS_SRC/$density"/*.png "$ANDROID_RES/mipmap-$density/" 2>/dev/null || true
            fi
            if [ -d "$ICONS_SRC/mipmap-$density" ]; then
              mkdir -p "$ANDROID_RES/mipmap-$density"
              cp -f "$ICONS_SRC/mipmap-$density"/*.png "$ANDROID_RES/mipmap-$density/" 2>/dev/null || true
            fi
          done
          ls -la "$ANDROID_RES/mipmap-xxxhdpi/" || true

      - name: Optimize Android package size
        run: |
          set -euo pipefail
          python - <<'PY'
          from pathlib import Path
          import re

          candidates = [
              Path("src-tauri/gen/android/app/build.gradle.kts"),
              Path("src-tauri/gen/android/app/build.gradle"),
          ]
          gradle = next((p for p in candidates if p.exists()), None)
          if gradle is None:
              raise SystemExit("Android Gradle file not found")

          text = gradle.read_text(encoding="utf-8")
          original = text

          release_match = re.search(r'getByName\("release"\)\s*\{', text)
          if release_match:
              inject = []
              if "isMinifyEnabled = true" not in text:
                  inject.append("            isMinifyEnabled = true")
              if "isShrinkResources = true" not in text:
                  inject.append("            isShrinkResources = true")
              if "proguard-android-optimize.txt" not in text:
                  inject.append('            proguardFiles(getDefaultProguardFile("proguard-android-optimize.txt"), "proguard-rules.pro")')
              if inject:
                  text = text[: release_match.end()] + "\n" + "\n".join(inject) + text[release_match.end() :]

          if "packaging {" not in text:
              android_match = re.search(r'android\s*\{', text)
              if android_match:
                  packaging_block = (
                      "\n"
                      "    packaging {\n"
                      "        resources {\n"
                      "            excludes += \"/META-INF/{AL2.0,LGPL2.1}\"\n"
                      "            excludes += \"META-INF/*.version\"\n"
                      "            excludes += \"**/*.kotlin_module\"\n"
                      "        }\n"
                      "    }\n"
                  )
                  text = (
                      text[: android_match.end()]
                      + packaging_block
                      + text[android_match.end() :]
                  )

          if text != original:
              gradle.write_text(text, encoding="utf-8")
              print(f"Patched {gradle}")
          else:
              print(f"No patch needed for {gradle}")

          proguard = Path("src-tauri/gen/android/app/proguard-rules.pro")
          if not proguard.exists():
              proguard.write_text(
                  "# Keep Tauri bridge and WebView JS interfaces to avoid runtime issues after minify.\n"
                  "-keep class app.tauri.** { *; }\n"
                  "-keep class com.tauri.** { *; }\n"
                  "-keep class androidx.webkit.** { *; }\n"
                  "-keepclassmembers class * {\n"
                  "    @android.webkit.JavascriptInterface <methods>;\n"
                  "}\n",
                  encoding="utf-8",
              )
              print(f"Created {proguard}")
          PY

      - name: Build Android APK (arm64 only)
        run: npm run tauri android build -- --target aarch64 --apk true
        env:
          NDK_HOME: ${{ env.NDK_HOME }}

      - name: Sign APK
        run: |
          set -euo pipefail
          VERSION="${GITHUB_REF#refs/tags/v}"
          if [ -z "$VERSION" ] || [ "$VERSION" = "$GITHUB_REF" ]; then
            VERSION="$(node -p "require('./package.json').version")"
          fi
          if [ -z "$VERSION" ]; then
            echo "Unable to resolve VERSION"
            exit 1
          fi

          UNSIGNED_APK="$(find src-tauri/gen/android/app/build/outputs/apk -name '*.apk' | head -n 1)"
          if [ -z "$UNSIGNED_APK" ]; then
            echo "No unsigned APK found."
            find src-tauri/gen/android/app/build/outputs -maxdepth 6 -type f -print || true
            exit 1
          fi
          echo "Found unsigned APK: $UNSIGNED_APK"

          if [ -n "${{ secrets.ANDROID_KEYSTORE_BASE64 }}" ]; then
            echo "${{ secrets.ANDROID_KEYSTORE_BASE64 }}" | base64 -d > release-key.jks
            echo "Using keystore from secret"
          else
            keytool -genkeypair -v \
              -keystore release-key.jks \
              -alias mini-hbut \
              -keyalg RSA \
              -keysize 2048 \
              -validity 10000 \
              -storepass android \
              -keypass android \
              -dname "CN=Mini-HBUT, OU=HBUT, O=HBUT, L=Wuhan, ST=Hubei, C=CN"
            echo "Generated fallback keystore"
          fi

          "${ANDROID_SDK_ROOT}/build-tools/35.0.0/zipalign" -v -p 4 "$UNSIGNED_APK" app-aligned.apk
          APK_NAME="Mini-HBUT_${VERSION}_arm64.apk"
          "${ANDROID_SDK_ROOT}/build-tools/35.0.0/apksigner" sign \
            --ks release-key.jks \
            --ks-key-alias mini-hbut \
            --ks-pass pass:android \
            --key-pass pass:android \
            --out "$APK_NAME" \
            app-aligned.apk
          "${ANDROID_SDK_ROOT}/build-tools/35.0.0/apksigner" verify -v "$APK_NAME"
          ls -lh "$APK_NAME"

      - name: Upload signed APK
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ github.ref_name }}
          files: Mini-HBUT_*_arm64.apk
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  build-windows:
    needs: create-release
    runs-on: windows-latest
    steps:
      - uses: actions/checkout@v4

      - name: Get version from tag
        id: version
        shell: pwsh
        run: |
          $ver = "${env:GITHUB_REF}" -replace '^refs/tags/v', ''
          "VERSION=$ver" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: npm

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Install dependencies
        run: npm ci

      - name: Build Windows App
        run: npm run tauri build

      - name: Rename Windows artifacts to tag version
        shell: pwsh
        env:
          VERSION: ${{ steps.version.outputs.VERSION }}
        run: |
          New-Item -ItemType Directory -Path dist-release -Force | Out-Null
          $exe = Get-ChildItem "src-tauri/target/release/bundle/nsis/*.exe" | Select-Object -First 1
          if (-not $exe) { throw "NSIS exe not found" }
          Copy-Item $exe.FullName ("dist-release/Mini-HBUT_{0}_x64-setup.exe" -f $env:VERSION) -Force

          $msi = Get-ChildItem "src-tauri/target/release/bundle/msi/*.msi" | Select-Object -First 1
          if ($msi) {
            $msiName = ("Mini-HBUT_{0}_x64.msi" -f $env:VERSION)
            if ($msi.Name -match "en-US") { $msiName = ("Mini-HBUT_{0}_x64_en-US.msi" -f $env:VERSION) }
            Copy-Item $msi.FullName ("dist-release/" + $msiName) -Force
          }
          Get-ChildItem dist-release | Format-Table Name,Length -AutoSize

      - name: Upload Windows artifacts
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ github.ref_name }}
          files: dist-release/*
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  build-macos:
    needs: create-release
    runs-on: macos-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: npm

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: aarch64-apple-darwin,x86_64-apple-darwin

      - name: Install dependencies
        run: npm ci

      - name: Build macOS App (Universal, app only)
        run: npm run tauri build -- --target universal-apple-darwin --bundles app

      - name: Package macOS DMG manually
        run: |
          set -euo pipefail
          VERSION="${GITHUB_REF#refs/tags/v}"
          APP_PATH="$(find src-tauri/target/universal-apple-darwin/release/bundle/macos -maxdepth 1 -type d -name "*.app" | head -n 1 || true)"
          if [ -z "$APP_PATH" ]; then
            echo "No macOS .app found."
            find src-tauri/target/universal-apple-darwin/release/bundle -maxdepth 4 -type d -print || true
            exit 1
          fi

          APP_NAME="$(basename "$APP_PATH" .app)"
          DMG_NAME="${APP_NAME}_${VERSION}_universal.dmg"
          ZIP_NAME="${APP_NAME}_${VERSION}_universal.app.zip"

          WORK_DIR="$(mktemp -d)"
          cp -R "$APP_PATH" "$WORK_DIR/"

          hdiutil create \
            -volname "$APP_NAME" \
            -srcfolder "$WORK_DIR" \
            -ov \
            -format UDZO \
            "$DMG_NAME"

          ditto -c -k --sequesterRsrc --keepParent "$APP_PATH" "$ZIP_NAME"

          ls -lh "$DMG_NAME" "$ZIP_NAME"

      - name: Upload macOS artifacts
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ github.ref_name }}
          files: |
            Mini-HBUT_*_universal.dmg
            Mini-HBUT_*_universal.app.zip
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  build-ios:
    needs: create-release
    runs-on: macos-latest
    steps:
      - uses: actions/checkout@v4

      - name: Get version from tag
        id: version
        run: echo "VERSION=${GITHUB_REF#refs/tags/v}" >> "$GITHUB_OUTPUT"

      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: aarch64-apple-ios

      - name: Install Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: npm

      - name: Install Frontend Dependencies
        run: npm ci

      - name: Install Tauri CLI
        run: npm install -g @tauri-apps/cli

      - name: Build iOS app bundle
        run: |
          set -euo pipefail
          # Force production web assets for iOS CI builds.
          # If devUrl is present, runtime may try to open localhost:1420.
          node --input-type=module - <<'NODE'
          import fs from 'node:fs';
          const p = 'src-tauri/tauri.conf.json';
          const conf = JSON.parse(fs.readFileSync(p, 'utf8'));
          conf.build = conf.build || {};
          delete conf.build.devUrl;
          delete conf.build.beforeDevCommand;
          conf.build.beforeBuildCommand = 'npm run build';
          conf.build.frontendDist = conf.build.frontendDist || '../dist';
          fs.writeFileSync(p, JSON.stringify(conf, null, 2) + '\n');
          console.log('Patched tauri.conf.json for iOS CI:', {
            frontendDist: conf.build.frontendDist,
            hasDevUrl: Object.prototype.hasOwnProperty.call(conf.build, 'devUrl'),
          });
          NODE

          npm run tauri ios init

          IOS_ICON_DIR="src-tauri/icons/ios"
          IOS_APPICONSET="src-tauri/gen/apple/Assets.xcassets/AppIcon.appiconset"
          if [ -d "$IOS_ICON_DIR" ] && [ -d "$IOS_APPICONSET" ]; then
            find "$IOS_APPICONSET" -type f -name "*.png" -delete
            cp -f "$IOS_ICON_DIR"/*.png "$IOS_APPICONSET"/
            echo "Injected iOS AppIcon set from $IOS_ICON_DIR"
          else
            echo "iOS icon source or destination not found, skipping icon injection"
          fi

          npm run build

          export TMPDIR="$PWD/.tauri-tmp"
          export NPM_CONFIG_AUDIT=false
          export NPM_CONFIG_FUND=false
          mkdir -p "$TMPDIR"

          npm install ws --no-save --no-audit --no-fund
          node -e "require('ws'); console.log('ws ok')"

          cp tools/ci/tauri-cli-options-server.cjs "$TMPDIR/tauri-cli-options-server.cjs"

          IDENTIFIER="$(node -p "require('./src-tauri/tauri.conf.json').identifier")"
          PORT="$(python -c "import socket; s=socket.socket(); s.bind(('127.0.0.1', 0)); print(s.getsockname()[1]); s.close()")"
          export PORT
          echo "127.0.0.1:$PORT" > "$TMPDIR/${IDENTIFIER}-server-addr"

          LOG="$TMPDIR/tauri-cli-options-server.log"
          TAURI_CLI_OPTIONS_PORT="$PORT" TMPDIR="$TMPDIR" NODE_PATH="$PWD/node_modules" node "$TMPDIR/tauri-cli-options-server.cjs" >"$LOG" 2>&1 &
          OPTIONS_PID=$!
          cleanup() {
            if [ -n "${OPTIONS_PID:-}" ] && kill -0 "$OPTIONS_PID" 2>/dev/null; then
              kill "$OPTIONS_PID"
            fi
          }
          trap cleanup EXIT

          sleep 1
          if ! kill -0 "$OPTIONS_PID" 2>/dev/null; then
            echo "WS server process exited early"
            cat "$LOG"
            exit 1
          fi

          python - <<'PY'
          import os
          import socket
          import sys
          import time

          port = int(os.environ["PORT"])
          for _ in range(60):
              sock = socket.socket()
              sock.settimeout(0.2)
              try:
                  sock.connect(("127.0.0.1", port))
                  sock.close()
                  sys.exit(0)
              except Exception:
                  sock.close()
                  time.sleep(0.2)
          sys.exit(1)
          PY

          # Fallback: if tauri-cli resolves debug output path, make sure the static lib exists there too.
          mkdir -p src-tauri/target/aarch64-apple-ios/debug
          ln -sf ../release/libhbut_helper_lib.a src-tauri/target/aarch64-apple-ios/debug/libhbut_helper_lib.a

          TMPDIR="$TMPDIR" xcodebuild \
            -workspace src-tauri/gen/apple/hbut-helper.xcodeproj/project.xcworkspace \
            -scheme hbut-helper_iOS \
            -configuration Release \
            -sdk iphoneos \
            -destination "generic/platform=iOS" \
            -derivedDataPath build-ios \
            CODE_SIGNING_ALLOWED=NO \
            CODE_SIGNING_REQUIRED=NO \
            CODE_SIGNING_IDENTITY="" \
            DEVELOPMENT_TEAM=""

      - name: Package IPA for SideStore
        env:
          VERSION: ${{ steps.version.outputs.VERSION }}
        run: |
          set -euo pipefail
          mkdir -p Payload

          APP_PATH=""
          for PATTERN in "*/Release-iphoneos/*.app" "*/release-iphoneos/*.app" "*/Debug-iphoneos/*.app" "*/debug-iphoneos/*.app"; do
            APP_PATH="$(find build-ios/Build/Products -path "$PATTERN" -type d | head -n 1 || true)"
            if [ -n "$APP_PATH" ]; then
              break
            fi
          done
          if [ -z "$APP_PATH" ]; then
            APP_PATH="$(find build-ios/Build/Products -path "*/iphoneos/*.app" -type d | head -n 1 || true)"
          fi
          if [ -z "$APP_PATH" ]; then
            echo "No iPhoneOS .app found under build-ios/Build/Products"
            find build-ios/Build/Products -maxdepth 6 -type d -print || true
            exit 1
          fi

          echo "Using app: $APP_PATH"

          APP_BIN="$(/usr/libexec/PlistBuddy -c "Print :CFBundleExecutable" "$APP_PATH/Info.plist" 2>/dev/null || basename "$APP_PATH" .app)"
          if [ -f "$APP_PATH/$APP_BIN" ]; then
            xcrun strip -x -S "$APP_PATH/$APP_BIN" || true
          fi

          cp -R "$APP_PATH" Payload/
          IPA_NAME="Mini-HBUT_${VERSION}_iOS.ipa"
          zip -9 -r "$IPA_NAME" Payload
          ls -lh "$IPA_NAME"

      - name: Upload iOS IPA
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ github.ref_name }}
          files: Mini-HBUT_${{ steps.version.outputs.VERSION }}_iOS.ipa
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  build-linux:
    needs: create-release
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Get version from tag
        id: version
        run: echo "VERSION=${GITHUB_REF#refs/tags/v}" >> "$GITHUB_OUTPUT"

      - name: Install Linux dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            libwebkit2gtk-4.1-dev \
            libgtk-3-dev \
            libayatana-appindicator3-dev \
            librsvg2-dev \
            libssl-dev \
            build-essential

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: npm

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Install dependencies
        run: npm ci

      - name: Build Linux App
        run: npm run tauri build

      - name: Rename Linux artifacts to tag version
        env:
          VERSION: ${{ steps.version.outputs.VERSION }}
        run: |
          set -euo pipefail
          mkdir -p dist-release
          APPIMAGE="$(find src-tauri/target/release/bundle/appimage -name '*.AppImage' | head -n 1 || true)"
          DEB="$(find src-tauri/target/release/bundle/deb -name '*.deb' | head -n 1 || true)"
          if [ -z "$APPIMAGE" ] && [ -z "$DEB" ]; then
            echo "No Linux artifacts found"
            exit 1
          fi
          if [ -n "$APPIMAGE" ]; then
            cp "$APPIMAGE" "dist-release/Mini-HBUT_${VERSION}_amd64.AppImage"
          fi
          if [ -n "$DEB" ]; then
            cp "$DEB" "dist-release/Mini-HBUT_${VERSION}_amd64.deb"
          fi
          ls -lh dist-release

      - name: Upload Linux artifacts
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ github.ref_name }}
          files: dist-release/*
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

