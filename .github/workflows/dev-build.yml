name: Dev Build

on:
  push:
    branches:
      - dev
  workflow_dispatch:

permissions:
  contents: read

env:
  CARGO_INCREMENTAL: 0

concurrency:
  group: dev-build-${{ github.ref }}
  cancel-in-progress: true

jobs:
  source:
    runs-on: ubuntu-latest
    steps:
      - name: Fetch source (git fallback to tarball)
        env:
          GH_REPO: ${{ github.repository }}
          GH_SHA: ${{ github.sha }}
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail
          rm -rf source source.tar.gz .git-tmp .tar-tmp
          mkdir -p source

          fetched=0
          for i in 1 2 3 4 5; do
            echo "[source] git fetch attempt ${i}"
            rm -rf .git-tmp
            mkdir -p .git-tmp
            if (
              cd .git-tmp
              git init
              git remote add origin "https://x-access-token:${GH_TOKEN}@github.com/${GH_REPO}.git"
              git -c protocol.version=2 fetch --depth=1 origin "${GH_SHA}"
              git checkout --detach FETCH_HEAD
            ); then
              fetched=1
              break
            fi
            sleep $((i * 5))
          done

          if [ "${fetched}" -eq 1 ]; then
            echo "[source] git fetch succeeded"
            cp -a .git-tmp/. source/
            rm -rf source/.git
          else
            echo "[source] git fetch failed, fallback to codeload tarball"
            curl -fL --retry 8 --retry-all-errors --retry-delay 3 \
              "https://codeload.github.com/${GH_REPO}/tar.gz/${GH_SHA}" -o source.tar.gz
            mkdir -p .tar-tmp
            tar -xzf source.tar.gz -C .tar-tmp --strip-components=1
            cp -a .tar-tmp/. source/
          fi

          test -f source/package.json
          tar -czf source.tar.gz -C source .

      - name: Upload source artifact
        uses: actions/upload-artifact@v4
        with:
          name: source-tar
          path: source.tar.gz
          if-no-files-found: error
          retention-days: 1

  meta:
    needs: source
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      beta_version: ${{ steps.version.outputs.beta_version }}
    steps:
      - name: Download source artifact
        uses: actions/download-artifact@v4
        with:
          name: source-tar
      - name: Extract source
        run: tar -xzf source.tar.gz

      - name: Resolve build version
        id: version
        run: |
          VERSION="$(python - <<'PY'
          import json
          with open('package.json', 'r', encoding='utf-8') as f:
              print(json.load(f).get('version', '0.0.0'))
          PY
          )"
          BETA_VERSION="${VERSION}-beta.${GITHUB_RUN_ID}"
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"
          echo "beta_version=$BETA_VERSION" >> "$GITHUB_OUTPUT"
          echo "VERSION=$VERSION"
          echo "BETA_VERSION=$BETA_VERSION"

  build-android:
    needs: [source, meta]
    runs-on: ubuntu-latest
    steps:
      - name: Download source artifact
        uses: actions/download-artifact@v4
        with:
          name: source-tar
      - name: Extract source
        run: tar -xzf source.tar.gz

      - name: Setup Java
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: "17"

      - name: Setup Android SDK
        uses: android-actions/setup-android@v3

      - name: Setup NDK
        run: |
          sdkmanager "ndk;27.0.11718014"
          echo "NDK_HOME=$ANDROID_SDK_ROOT/ndk/27.0.11718014" >> "$GITHUB_ENV"

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: npm

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: aarch64-linux-android

      - name: Install dependencies
        run: npm ci

      - name: Initialize Android project
        run: npm run tauri android init

      - name: Patch Android notification permissions
        run: |
          set -euo pipefail
          MANIFEST="src-tauri/gen/android/app/src/main/AndroidManifest.xml"
          if [ ! -f "$MANIFEST" ]; then
            echo "AndroidManifest.xml not found: $MANIFEST"
            exit 1
          fi
          python - <<'PY'
          from pathlib import Path
          p = Path("src-tauri/gen/android/app/src/main/AndroidManifest.xml")
          text = p.read_text(encoding="utf-8")
          perms = [
              "android.permission.POST_NOTIFICATIONS",
              "android.permission.WAKE_LOCK",
              "android.permission.FOREGROUND_SERVICE",
              "android.permission.REQUEST_IGNORE_BATTERY_OPTIMIZATIONS",
          ]
          for perm in perms:
              marker = f'android:name="{perm}"'
              if marker not in text:
                  text = text.replace(
                      "<application",
                      f'    <uses-permission android:name="{perm}" />\\n\\n    <application',
                      1,
                  )
          p.write_text(text, encoding="utf-8")
          print("Patched AndroidManifest permissions.")
          PY
          grep -n "POST_NOTIFICATIONS\\|WAKE_LOCK\\|FOREGROUND_SERVICE\\|REQUEST_IGNORE_BATTERY_OPTIMIZATIONS" "$MANIFEST"

      - name: Optimize Android package size
        run: |
          set -euo pipefail
          python - <<'PY'
          from pathlib import Path
          import re

          candidates = [
              Path("src-tauri/gen/android/app/build.gradle.kts"),
              Path("src-tauri/gen/android/app/build.gradle"),
          ]
          gradle = next((p for p in candidates if p.exists()), None)
          if gradle is None:
              raise SystemExit("Android Gradle file not found")

          text = gradle.read_text(encoding="utf-8")
          original = text

          release_match = re.search(r'getByName\("release"\)\s*\{', text)
          if release_match:
              inject = []
              if "isMinifyEnabled = true" not in text:
                  inject.append("            isMinifyEnabled = true")
              if "isShrinkResources = true" not in text:
                  inject.append("            isShrinkResources = true")
              if "proguard-android-optimize.txt" not in text:
                  inject.append('            proguardFiles(getDefaultProguardFile("proguard-android-optimize.txt"), "proguard-rules.pro")')
              if inject:
                  text = text[: release_match.end()] + "\n" + "\n".join(inject) + text[release_match.end() :]

          if "packaging {" not in text:
              android_match = re.search(r'android\s*\{', text)
              if android_match:
                  packaging_block = (
                      "\n"
                      "    packaging {\n"
                      "        resources {\n"
                      "            excludes += \"/META-INF/{AL2.0,LGPL2.1}\"\n"
                      "            excludes += \"META-INF/*.version\"\n"
                      "            excludes += \"**/*.kotlin_module\"\n"
                      "        }\n"
                      "    }\n"
                  )
                  text = (
                      text[: android_match.end()]
                      + packaging_block
                      + text[android_match.end() :]
                  )

          if text != original:
              gradle.write_text(text, encoding="utf-8")
              print(f"Patched {gradle}")
          else:
              print(f"No patch needed for {gradle}")

          proguard = Path("src-tauri/gen/android/app/proguard-rules.pro")
          if not proguard.exists():
              proguard.write_text(
                  "# Keep Tauri bridge and WebView JS interfaces to avoid runtime issues after minify.\n"
                  "-keep class app.tauri.** { *; }\n"
                  "-keep class com.tauri.** { *; }\n"
                  "-keep class androidx.webkit.** { *; }\n"
                  "-keepclassmembers class * {\n"
                  "    @android.webkit.JavascriptInterface <methods>;\n"
                  "}\n",
                  encoding="utf-8",
              )
              print(f"Created {proguard}")
          PY

      - name: Build Android APK (arm64)
        run: npm run tauri android build -- --target aarch64 --apk true
        env:
          NDK_HOME: ${{ env.NDK_HOME }}

      - name: Sign and rename APK
        env:
          BETA_VERSION: ${{ needs.meta.outputs.beta_version }}
        run: |
          set -euo pipefail
          UNSIGNED_APK="$(find src-tauri/gen/android/app/build/outputs/apk -name '*.apk' | head -n 1)"
          if [ -z "$UNSIGNED_APK" ]; then
            echo "No unsigned APK found."
            find src-tauri/gen/android/app/build/outputs -maxdepth 6 -type f -print || true
            exit 1
          fi

          if [ -n "${{ secrets.ANDROID_KEYSTORE_BASE64 }}" ]; then
            echo "${{ secrets.ANDROID_KEYSTORE_BASE64 }}" | base64 -d > release-key.jks
          else
            keytool -genkeypair -v \
              -keystore release-key.jks \
              -alias mini-hbut \
              -keyalg RSA \
              -keysize 2048 \
              -validity 10000 \
              -storepass android \
              -keypass android \
              -dname "CN=Mini-HBUT, OU=HBUT, O=HBUT, L=Wuhan, ST=Hubei, C=CN"
          fi

          "${ANDROID_SDK_ROOT}/build-tools/35.0.0/zipalign" -v -p 4 "$UNSIGNED_APK" app-aligned.apk
          OUT_APK="Mini-HBUT_${BETA_VERSION}_arm64.apk"
          "${ANDROID_SDK_ROOT}/build-tools/35.0.0/apksigner" sign \
            --ks release-key.jks \
            --ks-key-alias mini-hbut \
            --ks-pass pass:android \
            --key-pass pass:android \
            --out "$OUT_APK" \
            app-aligned.apk
          "${ANDROID_SDK_ROOT}/build-tools/35.0.0/apksigner" verify -v "$OUT_APK"
          ls -lh "$OUT_APK"

      - name: Upload Android artifact
        uses: actions/upload-artifact@v4
        with:
          name: android-${{ needs.meta.outputs.beta_version }}
          path: Mini-HBUT_${{ needs.meta.outputs.beta_version }}_arm64.apk
          if-no-files-found: error
          retention-days: 14

  build-windows:
    needs: [source, meta]
    runs-on: windows-latest
    steps:
      - name: Download source artifact
        uses: actions/download-artifact@v4
        with:
          name: source-tar
      - name: Extract source
        shell: powershell
        run: tar -xzf source.tar.gz

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: npm

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Install dependencies
        run: npm ci

      - name: Build Windows app
        run: npm run tauri build

      - name: Rename Windows bundles
        shell: powershell
        env:
          BETA_VERSION: ${{ needs.meta.outputs.beta_version }}
        run: |
          New-Item -ItemType Directory -Force -Path dist-dev | Out-Null
          $exe = Get-ChildItem "src-tauri/target/release/bundle/nsis/*.exe" | Select-Object -First 1
          if (-not $exe) { throw "NSIS EXE not found" }
          Copy-Item $exe.FullName "dist-dev/Mini-HBUT_$env:BETA_VERSION`_x64-setup.exe" -Force

          $msi = Get-ChildItem "src-tauri/target/release/bundle/msi/*.msi" | Select-Object -First 1
          if ($msi) {
            $msiName = "Mini-HBUT_$env:BETA_VERSION`_x64.msi"
            if ($msi.Name -match "en-US") {
              $msiName = "Mini-HBUT_$env:BETA_VERSION`_x64_en-US.msi"
            }
            Copy-Item $msi.FullName ("dist-dev/" + $msiName) -Force
          }
          Get-ChildItem dist-dev

      - name: Upload Windows artifacts
        uses: actions/upload-artifact@v4
        with:
          name: windows-${{ needs.meta.outputs.beta_version }}
          path: dist-dev/*
          if-no-files-found: error
          retention-days: 14

  build-macos:
    needs: [source, meta]
    runs-on: macos-latest
    steps:
      - name: Download source artifact
        uses: actions/download-artifact@v4
        with:
          name: source-tar
      - name: Extract source
        run: tar -xzf source.tar.gz

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: npm

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: aarch64-apple-darwin,x86_64-apple-darwin

      - name: Install dependencies
        run: npm ci

      - name: Build macOS app (universal, app only)
        run: npm run tauri build -- --target universal-apple-darwin --bundles app

      - name: Package macOS bundle
        env:
          BETA_VERSION: ${{ needs.meta.outputs.beta_version }}
        run: |
          set -euo pipefail
          mkdir -p dist-dev
          APP_PATH="$(find src-tauri/target/universal-apple-darwin/release/bundle/macos -maxdepth 1 -type d -name '*.app' | head -n 1 || true)"
          if [ -z "$APP_PATH" ]; then
            echo "macOS .app not found"
            find src-tauri/target/universal-apple-darwin/release/bundle -maxdepth 4 -type d -print || true
            exit 1
          fi

          APP_NAME="$(basename "$APP_PATH" .app)"
          DMG_OUT="dist-dev/Mini-HBUT_${BETA_VERSION}_universal.dmg"
          ZIP_OUT="dist-dev/Mini-HBUT_${BETA_VERSION}_universal.app.zip"

          WORK_DIR="$(mktemp -d)"
          cp -R "$APP_PATH" "$WORK_DIR/"

          hdiutil create \
            -volname "$APP_NAME" \
            -srcfolder "$WORK_DIR" \
            -ov \
            -format UDZO \
            "$DMG_OUT"

          ditto -c -k --sequesterRsrc --keepParent "$APP_PATH" "$ZIP_OUT"
          ls -lh dist-dev

      - name: Upload macOS artifact
        uses: actions/upload-artifact@v4
        with:
          name: macos-${{ needs.meta.outputs.beta_version }}
          path: dist-dev/*
          if-no-files-found: error
          retention-days: 14

  build-ios:
    needs: [source, meta]
    runs-on: macos-latest
    steps:
      - name: Download source artifact
        uses: actions/download-artifact@v4
        with:
          name: source-tar
      - name: Extract source
        run: tar -xzf source.tar.gz

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: aarch64-apple-ios

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: npm

      - name: Install dependencies
        run: npm ci

      - name: Install Tauri CLI
        run: npm install -g @tauri-apps/cli

      - name: Build iOS app bundle
        run: |
          set -euo pipefail
          node --input-type=module - <<'NODE'
          import fs from 'node:fs';
          const p = 'src-tauri/tauri.conf.json';
          const conf = JSON.parse(fs.readFileSync(p, 'utf8'));
          conf.build = conf.build || {};
          delete conf.build.devUrl;
          delete conf.build.beforeDevCommand;
          conf.build.beforeBuildCommand = 'npm run build';
          conf.build.frontendDist = conf.build.frontendDist || '../dist';
          fs.writeFileSync(p, JSON.stringify(conf, null, 2) + '\n');
          console.log('Patched tauri.conf.json for iOS CI.');
          NODE

          npm run tauri ios init
          npm run build

          export TMPDIR="$PWD/.tauri-tmp"
          export NPM_CONFIG_AUDIT=false
          export NPM_CONFIG_FUND=false
          mkdir -p "$TMPDIR"

          npm install ws --no-save --no-audit --no-fund
          node -e "require('ws'); console.log('ws ok')"

          cp tools/ci/tauri-cli-options-server.cjs "$TMPDIR/tauri-cli-options-server.cjs"

          IDENTIFIER="$(node -p "require('./src-tauri/tauri.conf.json').identifier")"
          PORT="$(python -c "import socket; s=socket.socket(); s.bind(('127.0.0.1', 0)); print(s.getsockname()[1]); s.close()")"
          export PORT
          echo "127.0.0.1:$PORT" > "$TMPDIR/${IDENTIFIER}-server-addr"

          LOG="$TMPDIR/tauri-cli-options-server.log"
          TAURI_CLI_OPTIONS_PORT="$PORT" TMPDIR="$TMPDIR" NODE_PATH="$PWD/node_modules" node "$TMPDIR/tauri-cli-options-server.cjs" >"$LOG" 2>&1 &
          OPTIONS_PID=$!
          cleanup() {
            if [ -n "${OPTIONS_PID:-}" ] && kill -0 "$OPTIONS_PID" 2>/dev/null; then
              kill "$OPTIONS_PID"
            fi
          }
          trap cleanup EXIT

          sleep 1
          if ! kill -0 "$OPTIONS_PID" 2>/dev/null; then
            echo "WS server process exited early"
            cat "$LOG"
            exit 1
          fi

          python - <<'PY'
          import os
          import socket
          import sys
          import time

          port = int(os.environ["PORT"])
          for _ in range(60):
              sock = socket.socket()
              sock.settimeout(0.2)
              try:
                  sock.connect(("127.0.0.1", port))
                  sock.close()
                  sys.exit(0)
              except Exception:
                  sock.close()
                  time.sleep(0.2)
          sys.exit(1)
          PY

          mkdir -p src-tauri/target/aarch64-apple-ios/debug
          ln -sf ../release/libhbut_helper_lib.a src-tauri/target/aarch64-apple-ios/debug/libhbut_helper_lib.a

          TMPDIR="$TMPDIR" xcodebuild \
            -workspace src-tauri/gen/apple/hbut-helper.xcodeproj/project.xcworkspace \
            -scheme hbut-helper_iOS \
            -configuration Release \
            -sdk iphoneos \
            -destination "generic/platform=iOS" \
            -derivedDataPath build-ios \
            CODE_SIGNING_ALLOWED=NO \
            CODE_SIGNING_REQUIRED=NO \
            CODE_SIGNING_IDENTITY="" \
            DEVELOPMENT_TEAM=""

      - name: Package IPA
        env:
          BETA_VERSION: ${{ needs.meta.outputs.beta_version }}
        run: |
          set -euo pipefail
          mkdir -p Payload

          APP_PATH=""
          for PATTERN in "*/Release-iphoneos/*.app" "*/release-iphoneos/*.app" "*/Debug-iphoneos/*.app" "*/debug-iphoneos/*.app"; do
            APP_PATH="$(find build-ios/Build/Products -path "$PATTERN" -type d | head -n 1 || true)"
            if [ -n "$APP_PATH" ]; then
              break
            fi
          done
          if [ -z "$APP_PATH" ]; then
            APP_PATH="$(find build-ios/Build/Products -path "*/iphoneos/*.app" -type d | head -n 1 || true)"
          fi
          if [ -z "$APP_PATH" ]; then
            echo "No iPhoneOS .app found under build-ios/Build/Products"
            find build-ios/Build/Products -maxdepth 6 -type d -print || true
            exit 1
          fi

          APP_BIN="$(/usr/libexec/PlistBuddy -c "Print :CFBundleExecutable" "$APP_PATH/Info.plist" 2>/dev/null || basename "$APP_PATH" .app)"
          if [ -f "$APP_PATH/$APP_BIN" ]; then
            xcrun strip -x -S "$APP_PATH/$APP_BIN" || true
          fi

          cp -R "$APP_PATH" Payload/
          IPA_NAME="Mini-HBUT_${BETA_VERSION}_iOS.ipa"
          zip -9 -r "$IPA_NAME" Payload
          ls -lh "$IPA_NAME"

      - name: Upload iOS artifact
        uses: actions/upload-artifact@v4
        with:
          name: ios-${{ needs.meta.outputs.beta_version }}
          path: Mini-HBUT_${{ needs.meta.outputs.beta_version }}_iOS.ipa
          if-no-files-found: error
          retention-days: 14

  build-linux:
    needs: [source, meta]
    runs-on: ubuntu-latest
    steps:
      - name: Download source artifact
        uses: actions/download-artifact@v4
        with:
          name: source-tar
      - name: Extract source
        run: tar -xzf source.tar.gz

      - name: Install Linux dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            libwebkit2gtk-4.1-dev \
            libgtk-3-dev \
            libayatana-appindicator3-dev \
            librsvg2-dev \
            libssl-dev \
            build-essential

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: npm

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Install dependencies
        run: npm ci

      - name: Build Linux app
        run: npm run tauri build

      - name: Rename Linux bundles
        env:
          BETA_VERSION: ${{ needs.meta.outputs.beta_version }}
        run: |
          set -euo pipefail
          mkdir -p dist-dev
          APPIMAGE="$(find src-tauri/target/release/bundle/appimage -name '*.AppImage' | head -n 1 || true)"
          DEB="$(find src-tauri/target/release/bundle/deb -name '*.deb' | head -n 1 || true)"

          if [ -z "$APPIMAGE" ] && [ -z "$DEB" ]; then
            echo "No Linux bundle found"
            exit 1
          fi

          if [ -n "$APPIMAGE" ]; then
            cp "$APPIMAGE" "dist-dev/Mini-HBUT_${BETA_VERSION}_amd64.AppImage"
          fi
          if [ -n "$DEB" ]; then
            cp "$DEB" "dist-dev/Mini-HBUT_${BETA_VERSION}_amd64.deb"
          fi
          ls -lh dist-dev

      - name: Upload Linux artifacts
        uses: actions/upload-artifact@v4
        with:
          name: linux-${{ needs.meta.outputs.beta_version }}
          path: dist-dev/*
          if-no-files-found: error
          retention-days: 14
